# 1. Network application

## 1. Цель работы
Освоение набора системных вызовов для создания socket-соединений различных типов для обмена данными на хостах и по сети.

## 2. Ход работы

### 2.1. 
Проанализируйте набор системных вызовов для серверной и клиентской сторон при организации соединений на сокетах под ОС Linux, принимая во внимание возможности различных видов сокетов и семейств адресации.

Общесистемные вызовы:
1. int socket(); – создает сокет и возвращает файловый дескриптор, который ссылается на этот сокет.
2. ssize_t send(); – используется для передачи сообщения в другой сокет.
3. ssize_t recv(); – используется для получения сообщения из сокета.
4. ssize_t write(); – записывает из буфера в файл, на который ссылается файловый дескриптор.
5. ssize_t read(); – считывает из файлового дескриптора в буфер.
6. int close(); – закрывает файловый дескриптор.

Системные вызовы на стороне сервера:
1. int bind(); – присваивает адрес сокету, на который ссылается файловый дескриптор.
2. int listen(); – помечает сокет как используемый для приема входящих запросов на подключение с помощью accept().
3. int accept(); – извлекает первый запрос на подключение в очереди ожидающих подключений для  прослушивающего  сокета, создает новый подключенный сокет и возвращает новый дескриптор файла, ссылающийся на этот сокет.
4. ssize_t write(); – записывает из буфера, на который ссылается файловый дескриптор.
5. ssize_t read(); – считывает из файлового дескриптора в буфер.
6. int close(); – закрывает файловый дескриптор.

Системный вызов на стороне клиента:
1. int connect(); – соединяет сокет, на который ссылается файловый дескриптор, с указанным в команде адресом. Формат этого адреса определяется адресным пространством сокета.

Виды сокетов:
1. SOCK_STREAM – указывает, что данные проходят через сокет как последовательный и двунаправленный поток байтов.
2. SOCK_DGRAM – указывает, что данные, проходящие через сокет, будут в форме дейтаграмм. 
3. SOCK_SEQPACKET – указывает, что данные, проходящие через сокет, будут в форме последовательных пакетов. сохраняет границы сообщений и доставляет сообщения в том порядке, в котором они были отправлены.

Семейства адресации:
1. AF_INET – за счёт использования протокола IPv4 обеспечивает межпроцессное взаимодействие между процессами, работающими в одной и той же системе или в разных системах.
2. AF_INET6 – то же, что и в п.1, но поддерживает IPv6.
3. AF_UNIX – используется для связи процессов в одной машине.

### 2.2.
Скомпилируйте  и  выполните  программу  socketpair.cpp,  иллюстрирующую создание  простейшего  вида  сокета  и  обмен  данными  двух  родственных процессов. Проанализируйте вывод на консоль. Существует ли зависимость обмена от различных соотношений величин временных задержек (в вызовах sleep()) в процессе-родителе и в процессе-потомке?

Результат компиляции и исполнения программы представлен на картинке ниже:

![socketpairComp](images/task-1/socketPair.png)

С помощью функции socketpair создаётся пара взаимосвязанных сокетов, через которые производится общение процесса-родителя и процесса-потомка. Данные проходят через сокет как поток байтов. Семество адресации AF_UNIX указано, поскольку всё действие происходит в рамках одной машины.

В основном цикле программы 5 раз происходит обмен сообщениями:
* Процесс-потомок посылает родителю сообщение "c:%d", где %d - номер итерации.
* Процесс-родитель посылает потомку сообщение "p:%d", где %d - номер итерации.

Процесс-родитель выводит полученные сообщения в консоль в формате "p->%s", а процесс-потомок - в формате "c->%s", где %s - полученное собщение. Поскольку цикл "родителя" сначала читает буфер и пишет в консоль его содержимое, и только затем отправляет своё сообщение, то в результате в консоли можно видеть последовательность чисел от 0 до 9.

Системные вызовы read() и write() являются блокирующими, поэтому изменение величин временных задержек в вызовах sleep() не влияет на результат вывода программы.

### 2.3.

Скомпилируйте программы echo_server.cpp и echo_client.cpp, задавая им при компиляции разные имена. Запустите программы сервера и клиента на разных терминалах. Введите символьную информацию в окне клиента и проанализируйте вывод. Какой разновидности принадлежат сокеты, используемые в данном примере клиент-серверного взаимодействия? С чем связано создание специального файла в текущем каталоге во время исполнения программ?

Результат компиляции и исполнения программ представлены на картинках ниже:

![echo_serverComp](images/task-1/echo_serverComp.png)

![echo_clientComp](images/task-1/echo_clientComp.png)

Программа-клиент считывает и отправляет строку программе-серверу, которая отправляет её обратно. Клиент выводит полученное сообение в консоль.

Разновидность сокета указывается при его создании:
* домен AF_UNIX - обеспечивает взаимодействие между процессами на одной машине
* SOCK_STREAM - потоковые сокеты обеспечивающие соединение, представляющее собой последовательный и надежный двунаправленный поток байтов.

При запуске сервера в директории создаётся файл сокета, который используется для взаимодействия сервера и клиента. Сервер открывает данный сокет, клиент подключается и происходит обмен информацией. Из этого файла можно получить информацию о соединении (статус соединения, колчество пакетов в очереди на отправку и получение, используемые порты) с помощью команды ss:

![ss](images/task-1/ss.png)

### 2.4.

Скомпилируйте c разными именами программы sock_c_i_srv.cpp и sock_c_i_clt.cpp (в них используется общий include файл local_c_i.h). Запустите программы сервера и клиента на разных терминалах. При запуске клиента указывайте в качестве параметра командной строки имя хоста localhost. Введите символьную информацию в окне клиента и поясните вывод. Какой разновидности принадлежат сокеты, используемые в данном примере клиент-серверного взаимодействия?

Результат компиляции и исполнения программ представлены на картинках ниже:

![sock_cl](images/task-1/sock_cl.png)

![sock_sr](images/task-1/sock_sr.png)

Программа-клиент для работы требует ip-адрес сервера, в данном случае в качестве этого параметра указан "localhost". Клиент считывает и отправляет строку программе-серверу, которая переводит её в верхний регистр и отправляет обратно. Клиент выводит полученное сообение в консоль.

При созднии сокета  указывалось семейство адресации AF_INET, то есть взаимодействие по сети является возможным.

### 2.5.

Модифицируйте программу echo_server.cpp так, чтобы при ответе на запросы клиента что-либо выводилось в окне сервера. Испытайте работу эхо-сервера при работе с несколькими клиентами.

Измененённая версия программы приводится ниже:

```cpp
/*
** echo_server.cpp -- the echo server for echo_cient.cpp; demonstrates UNIX sockets
*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>

#define SOCK_PATH "echo_socket"

int main(void)
{
	int s, s2, t, len;
	struct sockaddr_un local, remote;
	char str[100];

	if ((s = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
		perror("socket");
		exit(1);
	}

	local.sun_family = AF_UNIX;
//	remote.sun_family = AF_UNIX;       //
	strcpy(local.sun_path, SOCK_PATH);
	unlink(local.sun_path);
	len = strlen(local.sun_path) + sizeof(local.sun_family);
	if (bind(s, (struct sockaddr *)&local, len) == -1) {
		perror("bind");
		exit(1);
	}

	if (listen(s, 5) == -1) {
		perror("listen");
		exit(1);
	}

	for(;;) {
		int done, n;
		printf("Waiting for a connection...\n");
		t = sizeof(remote);
		if ((s2 = accept(s, (struct sockaddr *)&remote, (socklen_t *)&t)) == -1) {
			perror("accept");
			exit(1);
		}

		printf("Connected.\n");

		done = 0;
		do {
			n = recv(s2, str, 100, 0);
			if (n <= 0) {
				if (n < 0) perror("recv");
				done = 1;
			}

			if (!done)
                printf("From clt # %d: %s", s2, str);
				if (send(s2, str, n, 0) < 0) {
					perror("send");
					done = 1;
				}
		} while (!done);

		close(s2);
	}

	return 0;
}
```

Работа сервера и двух клиентов приведена ниже:

![EcSerMod](images/task-1/EcSerMod.png)

![ecClt1](images/task-1/ecClt1.png)

![ecClt2](images/task-1/ecClt2.png)

Можно видеть, что сервер может работать только с одним клиентом. Первый клиент был подключен первым, и только его сообщения обрабатывались сервером. Это связано с тем, что сервер, установив соединение с одним клиентом, переводит соединение с остальными клиентами в состояние блокировки. Чтобы избавится от этого недостатка, следует разделить работу сервера на несколько потоков.

## Выводы

В ходе выполнения данной работы были изучены основные системные вызовы для создания сокетных соединений различных типов для обмена данными на хост-машине и по сети.

# 2. L4 Socket sample

## 1. Цель работы
Создание клиент-серверных приложений, взаимодействующих друг с другом по сети на основе технологии соединения на сокетах L4.

## 2. Ход работы

### 2.1.

Проанализируйте код программы server_game.cpp, иллюстрирующей обмен данными с клиентскими приложениями по итеративной схеме.

В данной программе, сначала создаётся серверный сокет, использующийся для входящих сообщений. В структуру server записывается информация о параметрах сокета и соединения. Затем сокет привязывается к ip-адресу, настроенному в данной структуре. Сервер начинает прослушивание входящих соединений с очередью в 5 клиентов.

Когда к сокету подключается клиент, начинается игра "угадай слово". Клиент-игрок вводит буквы, а сервер, при наличии буквы в загаданном слове, раскрывает её. Как только все буквы разгаданы, игра заканчивается.

### 2.2.

Скомпилируйте и запустите server_game.

Результат компиляции и исполнения программы представлен на картинке ниже:

![gameServerComp](images/task-2/gameServerComp.png)

### 2.3.

Запустите другой терминал и проверьте с него наличие в системе созданного сервером сокета и то, что он находится в состоянии LISTEN. Для этого выполните команду netstat -a | grep 1066. Проанализируйте вывод данной команды и объясните ее смысл.

Результат выполнения команды можно видеть на картинке ниже:

![grep](images/task-2/grep.png)

Можно видеть информацию о порте 1066:
* Используется протокол tcp.
* Размер очереди - очереди 0 байт.
* Локальный адрес.
* Удаленный адрес. Звездочка означает, что подключенных клиентов нет.
* Внутреннее состояние протокола.

### 2.4.

Запустите в качестве клиентского процесса утилиту telnet с параметрами: telnet localhost 1066. При организации коммуникации по сети на разных компьютерах вместо localhost при запуске клиента указывается IP-адрес компьютера, на котором был запущен сервер.

Результат запуска утилиты можно видеть на картинке ниже:

![telnet](images/task-2/telnet.png)

### 2.5.

Диалог с сервером заключается в угадывании слова. Оно вводится по буквам с клиентского терминала. При этом сервер вместо неугаданных букв выдает символы ”-” , а также считает число оставшихся неудачных попыток (всего их предусмотрено 12).

На картинке ниже приведен пример работы с помощью утилиты telnet, запущенной в предыдущем пункте.

![telnet1](images/task-2/telnet1.png)

### 2.6.

Завершите серверное приложение с помощью сигнала kill, и затем определите командой netstat -a | grep 1066, когда исчезает из системы соединение на сокетах. Во время сеанса обмена также примените команду netstat -a | grep 1066, чтобы исследовать состояние соединения.

Во время игры появились два соединения от сервера к клиенту на порт 58140, и обратно. Оба соединения находятся в состоянии ESTABLISHED, что означает, что соединение установлено:

![netstat1](images/task-2/netstat1.png)

После завершения программы, происходит закрытие соединения сервером. Состояние соединения TIME_WAIT означает, что у сервера превышено время ожидания ответа:

![netstat2](images/task-2/netstat2.png)

Спустя некоторое время, TCP-соединение пропадает из списка окончательно:

![netstat3](images/task-2/netstat3.png)

### 2.7.

Проделайте все заново, но запускайте не одно клиентское приложение (в виде telnet), а несколько экземпляров с разных терминалов, и попытайтесь работать с них одновременно. Проанализируйте, как сервер будет обслуживать запросы в этом случае.

На картинке ниже запущены два клиента одновременно.

![parallel](images/task-2/parallel.png)

Можно видеть, что сервер может работать только с одним клиентом (подключившимся первым). Однако, если первый клиент заканчивает игру, то сообщения второго клиента начинают обрабатываться. Можно сделать вывод, что программа обрабатывает клиентов последовательно.

### 2.8.

Модифицируйте программу server_game.cpp так, чтобы запросы от каждого из клиентов могли обслуживаться конкурентно, путем запуска для каждого нового соединения собственного нового процесса на сервере или потока. Проанализируйте, как обслуживаются запросы в случае конкурентной схемы работы сервера. Возможно также улучшить качество самой игровой функции guess_word() сервера.

guess_word() оставлена неизменной.

```cpp
/* The program server_game.cpp */

/* Server for the guess_word game (iterative schema) */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <ctype.h>
#include <syslog.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <errno.h>

int maxlives = 12;

#define MAXLEN	80		/* max size of string */
#define SERVER_GAME_TCP_PORT	1066


void guess_word(int, int);

main(void)
{
int 	sock, fd, client_len;
struct	sockaddr_in server, client;

sock = socket(AF_INET, SOCK_STREAM, 0);
  if (sock < 0)	{
	perror("creating stream socket");
	exit(1);
		}

server.sin_family	= AF_INET;
server.sin_addr.s_addr	= htonl(INADDR_ANY);
server.sin_port		= htons(SERVER_GAME_TCP_PORT);

if (bind(sock, (struct sockaddr *) &server, sizeof (server)) < 0) {
	perror("binding socket");
	exit(2);
	}

listen(sock, 5);
printf("start to listen\n");

while (1)  {
    client_len = sizeof(client);
    if ((fd = accept(sock, (struct sockaddr *) &client, (socklen_t *)&client_len)) < 0)  {
	perror("accepting connection"); 
	exit(3);
		}

	printf("guess_word start");	

    if (fork() == 0)
    {
        guess_word(fd, fd);
    }
	close(fd);
}
}
```

В результате клонирования процесса с помощью функции fork(), сервер получил возможность работать с несколькими клиентами одновременно:

![parallelFixed](images/task-2/parallelFixed.png)

С помощью утилиты netstat можно подтвердить, что клиенты, действительно, подключены:

![netstatFixed](images/task-2/netstatFixed.png)

## Выводы

В ходе выполнения данной работы были получены сведения о работе 

# 3. GnuPG tool utilisation 1

## 1. Цель работы

Установка утилиты GnuPG, исследование ее режимов работы с различными опциями и ключами и выполнение команд из базового
списка.

## 2. Ход работы

Данная работа выполнялась на ОС Ubuntu 20.04.6 на WSL (Windows Subsystem for Linux).

![wsl](images/task-3/wsl.png)

## 3. Установка GNU PG2

Установим GNU PG2 (GPG2):

![installGPG](images/task-3/installGPG.png)

Выведем информацию о текущей версии GPG2:

![versionGPG](images/task-3/version.png)

## 4. Генерация ключей

Сгенерируем ключи для шифрования и подписи (тип 1), размером 4096 и бесконечным временем жизни:

![creation](images/task-3/creation.png)

Убедимся в том, что ключ действительно создан и распознан GPG2:

![list-after-creation](images/task-3/list-after-creation.png)

Действительно, сгенерированный ключ появился в списке. Выведем отпечаток ключа – в дальнейшем он потребуется для
проверки корректности импорта ключа с сервера:

![fingerprint](images/task-3/fingerprint.png)

Проверим структуру папки `.gnupg` после генерации ключей. Для этого воспользуемся утилитой `tree`, которая строит
файловую структуру заданной папки в удобном визуальном формате:

![gpg-dir](images/task-3/gpg-dir.png)

В полученной структуре можно заметить следующие объекты:

- Каталог, хранящий в себе открытые ключи (`opengp-revocs.d`);
- Каталог, хранящий в себе приватные ключи (`private-keys-v1.d`);
- Зашифрованный файл - связку открытых ключей (`pubring.kbx`);
- Файл с доверительной базой данных (`trustdb.gpg`).

## 5. Шифрация и дешифрация файла

Создадим документ с произвольным текстом для дальнейшей работы с ним:

![orig-text-creation](images/task-3/orig-text-creation.png)

Зашифруем созданный файл созданным ранее ключом:

![orig-text-encrypted](images/task-3/orig-text-encrypted.png)

Дешифруем полученный файл тем же ключом, сравним исходный и полученный файлы:

![orig-text-decrypted](images/task-3/orig-text-decrypted.png)

Различий между исходным файлом и результирующим файлом нет, что свидетельствует об успешном процессе шифрации и
дешифрации.

## 6. Создание цифровой подписи

Создадим новый файл, сгенерируем к нему цифровую подпись:

![orig2-text-key](images/task-3/orig2-text-key.png)

Проверим полученную цифровую подпись:

![orig2-text-verification](images/task-3/orig2-text-verification.png)

Полученный результат "Good signature" свидетельствует о том, что подписанному документу был найден соответствующий ключ
из хранилища.

## 7. Исследование прочих команд GPG2

При помощи GPG2 возможна и более тонкая настройка ключа при его создании при добавлении флага `--expert`. Попробуем
создать ещё один ключ подобным образом:

![expert-creation](images/task-3/expert-creation.png)

Очевидно, что помимо добавления и создания ключей доступна операция их удаления из хранилища. Попробуем удалить
созданные нами ключи в правильном порядке: сначала приватные, затем связанные с ними публичные:

![expert-removal](images/task-3/expert-removal.png)

## 8. Выводы

В рамках данной работы были изучены основы работы с GPG: создание и удаления пар ключей (публичный/приватный),
шифрация и дешифрация файлов при помощи ключей, создание электронной подписи файла и её проверка.

# 4. GnuPG tool utilisation 2

## 1. Цель работы

Импорт и экспорт ключей (цифровых подписей), шифрование сообщений с помощью цифровых подписей.

## 2. Ход работы

Данная работа выполнялась на ОС Ubuntu 20.04.6 на WSL (Windows Subsystem for Linux).

![wsl](images/task-3/wsl.png)

## 3. Создание и использование электронной цифровой подписи (ЭЦП)

Шифрация файлов и проверка подписей может осуществляться при помощи открытого ключа. Для дальнейшей работы используется
ключ, созданный в предыдущей лабораторной работе:

![created-key](images/task-4/created-key.png)

Экспортируем данный ключ во внешний файл:

![exported-key](images/task-4/exported-key.png)

Создадим новый файл для дальнейшей работы с ним:

![orig3-text-creation](images/task-4/orig3-text-creation.png)

Создадим для него отсоединённую ЭЦП в текстовом формате:

![orig3-text-sign-detached](images/task-4/orig3-text-sign-detached.png)

Аналогичным образом, создадим отсоединённую ЭЦП в бинарном формате:

![orig3-text-bin-sign-detached](images/task-4/orig3-text-bin-sign-detached.png)

После выполнения команды произошло создание файла ЭЦП `originalText3.txt.sig`, который и является отсоединённой ЭЦП.

Создадим встроенную в файл ЭЦП в текстовом формате:

![orig3-text-sign-attached](images/task-4/orig3-text-sign-attached.png)

Аналогичным образом, создадим встроенную ЭЦП в бинарном формате:

![orig3-text-bin-sign-attached](images/task-4/orig3-text-bin-sign-attached.png)

После выполнения команды произошло создание файла `originalText3.txt.gpg`.

## 4. Импорт и экспорт ключей

Предварительно отчистив хранилище ключей, импортируем созданный ранее ключ и убедимся в корректности его импорта:

![imported-key](images/task-4/imported-key.png)

Отредактируем импортированный ключ - установим к нему доверие, что потребуется для дальнейшей проверки ЭЦП:

![entrusted-key](images/task-4/entrusted-key.png)

Теперь, при наличии импортированного доверенного ключа, проверим отсоединённую ЭЦП из предыдущего пункта:

![verification-text](images/task-4/verification-text.png)

Полученный результат - Good signature - свидетельствует о том, что ключ соответствует использованному при генерации ЭЦП.

Экспортируем этот же ключ на внешний сервер keyserver.ubuntu.com, убедимся в том, что ключ действительно находится на
сервере:

![exported-keyserver](images/task-4/exported-keyserver.png)

Первая полученная ошибка может быть объяснена тем, что сервер не успел так быстро обработать полученный ключ - поэтому
первый запрос ключа закончился получением ошибки, а второй прошёл успешно.

Импортируем экспортированный ранее ключ:

![imported-keyserver](images/task-4/imported-keyserver.png)

Полученный с сервера ключ соответствует имеющемся, о чём говорит строка unchanged: 1 в результате.

## 5. Выводы

В рамках данной работы были изучены основные способы генерации встроенных и отсоединённых ЭЦП при помощи GPG2. Также был
получен практический опыт по импорту и экспорту ключей как в отдельный файл, так и на внешний сервер.

# 5. WireShark packet sniffing

## 1. Цель работы

Изучение основных способов поиска уязвимостей в сети по анализу сетевого трафика с помощью программы анализатора
Wireshark.

## 2. Ход работы

Данная работа осуществлялись на машине, подключенной к домашней сети со следующей конфигурацией:

- Локальный IPv6-адрес канала: `fe80::3a0e:bb5b:597d:e57b%11`
- IPv4-адрес: `192.168.1.38`
- Маска подсети: `255.255.255.0`
- Основной шлюз: `192.168.1.1`
- MAC-адрес: `28-D0-EA-DE-DB-CC`

## 3. Анализ ICMP-трафика

Протокол ICMP (Internet Control Message Protocol) предназначен для решения задач управления, тестирования, мониторинга
сети и нотификации об ошибках и проблемах связанных с сетью.

Трафик протокола ICMP порождается такими утилитами как например `ping` или `traceroute`.

### 3.1 ping

Утилита `ping` отправляет запросы (Echo-Request) протокола ICMP указанному узлу сети и фиксирует поступающие ответы
(Echo-Reply). Время между отправкой запроса и получением ответа (RTT) позволяет определять двусторонние задержки по
маршруту и частоту потери пакетов, т.е. косвенно определять загруженность на каналах передачи данных и промежуточных
устройствах.

Wireshark — программа-анализатор трафика компьютерных сетей. Данная программа может отслеживать весь сетевой трафик
в режиме реального времени, переводя сетевую карту в promisc mode (принятие всех сетевых пакетов вне зависимости от их
адресата). Т.к. ICMP является сетевым протоколом, то Wireshark может отслеживать соответствующий трафик.

Для того чтобы отследить ICMP-трафик, требуется предварительно запустить отслеживание пакетов в Wireshark.

Для генерации ICMP трафика использовалась команда `ping github.com`:

![ping.png](images/task-5/ping.png)

Было отправлено 4 эхо-запроса и получено 4 эхо-ответа. Соответствующий трафик был отслежен в Wireshark:

![ping-wireshark.png](images/task-5/ping-wireshark.png)

В отчете Wireshark видно 8 пакетов, о каждом из которого приведена краткая информация:

- IP-адрес отправителя пакета;
- IP-адрес получателя пакета;
- используемый протокол передачи данных;
- длинна пакета данных;
- информация, специфичная для используемого протокола.

Для каждого отслеженного пакета можно посмотреть более детальную информацию:

![echo-request.png](images/task-5/echo-request.png)

В детальном отчете о первым пакете можно увидеть следующую информацию:

- IP-адрес отправителя пакета: `192.168.1.38`;
- IP-адрес получателя пакета: `140.82.121.3`;
- количество хопов до получателя (ttl): `128`;
- тип протокола пакета: `ICMP`;
- тип icmp-пакета: `8` (пакет является эхо-запросом);
- код (подтип ICMP пакета): `0` (не важен для эхо-запросов);
- идентификатор (используется для сопоставления запроса с ответом): `1`;
- номер последовательности (используется для сопоставления запроса с ответом): `61`;
- контрольная сумма (используется для проверки ошибок передачи данных): `0x4d1e`.

Следом за эхо-запросом в отчете Wireshark можно увидеть пакет с соответствующим эхо-ответом:

![echo-reply.png](images/task-5/echo-reply.png)

В детальном отчете о втором пакете можно увидеть следующую информацию:

- IP-адрес отправителя пакета: `140.82.121.3`;
- IP-адрес получателя пакета: `192.168.1.38`;
- количество хопов до получателя (ttl): `53`;
- тип протокола пакета: `ICMP`;
- тип icmp-пакета: `0` (пакет является эхо-ответом);
- код (подтип ICMP пакета): `0` (не важен для эхо-ответов);
- идентификатор (используется для сопоставления запроса с ответом): `1`;
- номер последовательности (используется для сопоставления запроса с ответом): `61`;
- контрольная сумма (используется для проверки ошибок передачи данных): `0x551e`;
- время ответа: `41.74`.

### 3.2 tracert

Другой утилитой, использующей ICMP-протокол является `tracert`, предназначенная для определения маршрута к узлу с
заданным IP-адресом, посылая на него соответствующие эхо-запросы. В этих пакетах tracert использует разные значения
Time To Live (TTL). Поскольку каждый маршрутизатор на пути пакета уменьшает значение его поля TTL минимум на 1 перед
дальнейшей пересылкой пакета, значение TTL можно считать счетчиком переходов. Когда срок жизни пакета достигает нуля,
маршрутизатор отправляет ICMP-пакет с сообщением об истечении TTL на исходный компьютер. Отправитель получает данное
сообщение с IP-адресом хоста, на котором истек TTL. Так, инкрементируя значение TTL начиная с 1, последовательно
отправляются эхо-запросы до тех пор, пока один из них не достигнет адресата.

Для генерации трафика использовалась команда `tracert github.com`:

![tracert.png](images/task-5/tracert.png)

В отчете Wireshark видно множество пакетов

![tracert-wireshark.png](images/task-5/tracert-wireshark-1.png)

![tracert-wireshark.png](images/task-5/tracert-wireshark-2.png)

В общей сложности было зафиксировано 73 пакета (42 отправлено и 31 получено).

Далее детально рассматриваются некоторые пакеты:

![tracert-request-1.png](images/task-5/tracert-request-1.png)

1 пакет является исходящим, имеет тип 8 (эхо-запрос) и, как и ожидалось, его TTL равен 1.

![tracert-reply-1.png](images/task-5/tracert-reply-1.png)

2 пакет является входящим и имеет тип 11 (истек TTL). При этом отправителем является хост с IP-адресом 192.168.1.1,
т.е. это маршрутизатор домашней сети.

Следующие 4 пакета являются абсолютно аналогичными первым двум, т.к. `tracert` отправляет 3 запроса с одинаковым TTL в
качестве контрольных выстрелов в голову.

![tracert-request-2.png](images/task-5/tracert-request-2.png)

7 пакет является аналогичным 1 пакету, но его TTL равен 2.

![tracert-reply-2.png](images/task-5/tracert-reply-2.png)

8 пакет является аналогичным 2 пакету, но его IP-адрес отправителя является `10.145.63.1`.

Не сложно догадаться, что далее процедура продолжается: отправляется 3 эхо-запроса с одним TTL, TTL инкриминируется, и
так происходит до тех пор, пока ответы на эхо-запросы начнет отправлять непосредственный адресат запросов.

![tracert-request-3.png](images/task-5/tracert-request-3.png)

Один из последних пакетов (67) имеет TTL равный 14.

![tracert-reply-3.png](images/task-5/tracert-reply-3.png)

Пакет с ответом на этот запрос (68) имеет уже тип 8 – эхо-ответ, а IP-адрес отправителя – `140.82.121.3`, т.е. IP-адрес
домена `github.com`, что означает, что запрос достиг своей цели.

Последние 4 пакета являются контрольными парами запрос-ответов с таким же TTL.

Отправленных пакетов больше, чем полученных из-за того, что хосты на самом деле не обязаны отправлять что-либо при
истечении TTL, т.е. на часть запросов просто не приходило ответов.

## 4. Анализ ARP-трафика

Для передачи данных внутри сети хост должен знать MAC-адрес хоста, которому передаются данные. Для получения МАС-адреса
по известному IP-адресу используется протокол ARP, который работает в режиме запрос-ответ: запрос отправляется на
широковещательный адрес, после чего каждый хост в подсети получает этот запрос и проверяет на соответствие свой
IP-адрес, и при совпадении посылает ARP-ответ непосредственно отправителю, используя его MAC-адрес. Целью протокола ARP
является заполнение ARP-таблицы: на
приемной стороне при получении ARP-запроса, на запрашивающей стороне при получении ответа.

Для начала нужно определить, кому внутри домашней сети можно отправить ARP-запрос. Посмотреть это можно в графическом
web-интерфейсе маршрутизатора сети:

![connected-devices.png](images/task-5/connected-devices.png)

В сети имеется множество клиентов, в том числе и используемый хост с адресом `192.168.1.38`.

Попробуем определить MAC-адрес хоста с адресом `192.168.1.33`. Чтобы узнать MAC-адрес хоста, требуется отправить
ARP-запрос. Для этого можно воспользоваться командой `ping 192.168.1.33`, которая сформирует широковещательный
ARP-запрос, который можно отследить в Wireshark:

![ping-arp-wireshark.png](images/task-5/ping-arp-wireshark.png)

Было зафиксировано 2 запроса c типом протокола ARP.

![arp-broadcast.png](images/task-5/arp-broadcast.png)

Первый пакет имеет информацию об отправителе (IP- и MAC-адреса) и IP-адрес хоста, MAC-адрес которого
требуется узнать (при этом MAC-адрес цели заполнен нулями). Также, как пакет протокола ARP, в нем
содержится поле Opcode равное 1, что означает широковещательный ARP-запрос. И действительно, в качестве получателя в
пакете указан широковещательный MAC-адрес `ff:ff:ff:ff:ff:ff`.

![arp-broadcast-reply.png](images/task-5/arp-broadcast-reply.png)

Второй пакет имеет Opcode 2, обозначающий ответ на широковещательный ARP-запрос, информацию о своем отправителе,
включая IP- и MAC-адрес (IP-адрес в данном случае тот же, на который посылался ARP-запрос, и который собственно
ожидался), и IP- и MAC-адрес получателя (в данном случае совпадает с данными хоста, с которого посылался запрос).

## 5. Анализ FTP-трафика

FTP (File Transfer Protocol) — протокол передачи файлов, который применяется для обмена файлами по TCP/IP сетям между
двумя компьютерами: клиентом и сервером. Используется транспорт TCP и передача текстовых команд, то есть в одну сторону
отправляются текстовые команды с параметрами, а в обратную сторону передаются текстовые ответы со статусами.
Поддерживается активный и пассивный режимы взаимодействия.

Соединяясь с FTP сервером допустимо пройти авторизацию предоставляя данные для входа, а также можно подключиться
анонимно, если это позволяет FTP сервер.

Основное назначение FTP протокола — это загрузка файлов и их скачивание с удалённого сервера. Для передачи файлов в
активном режиме организуется канал команд со стороны клиента, и создаётся соединение с 21 портом сервера. Когда
потребуется передача данных, сервер самостоятельно с 20 номера порта организует связь с клиентским сокетом, то есть
второй канал для данных. Данные при этом могут посылаться в обе стороны. В пассивном режиме схема похожая с активным,
только канал связи (данных) открывает 52 клиент. Номер порта у сервера каждый раз выбирается новым, и информация об этом
порте передаётся клиенту.

Подключение будет производиться к FTP-серверу `test.rebex.net` по адресу `194.108.117.16` при помощи программы WinSCP.

![ftp-tcp-connection.png](images/task-5/ftp-tcp-connection.png)

В отчете Wireshark можно видеть сегменты установления TCP-соединения. Порт клиента – 21970, а сервера – 21.

![ftp-login.png](images/task-5/ftp-login.png)

Далее в отчете следуют пакеты, смысл которых можно описать как процесс аутентификации.

- получение FTP-сообщения с кодом 220;
- отправка логина;
- получение запроса пароля;
- отправка пароля;
- получение сообщения об успешной аутентификации.

![ftp-220.png](images/task-5/ftp-220.png)

1 пакет был входящим, имел имя FTP сервера и код FTP 220, который означает готовность сервера для идентификации нового
пользователя.

![ftp-user-data.png](images/task-5/ftp-user-data.png)

2 пакет был исходящим, имел имя пользователя для аутентификации.

![ftp-password-required.png](images/task-5/ftp-password-required.png)

3 пакет был входящим, имел сообщение о запросе пароля для аутентификации.

![ftp-password-data.png](images/task-5/ftp-password-data.png)

4 пакет был исходящим, имел пароль для аутентификации.

![ftp-login-success.png](images/task-5/ftp-login-success.png)

5 пакет был входящим, имел код FTP 230, который означает успешную аутентификацию пользователя.

## 6. Повышение безопасности FTP-соединения

Для повышения безопасности соединения было решено добавить в настройках подключения WinSCP явное шифрование TLS/SSL:

![ftp-winscp-settings.png](images/task-5/ftp-winscp-settings.png)

![ftp-tls.png](images/task-5/ftp-tls.png)

Теперь вместо идентификации поступает запрос “AUTH TLS”, который переводит FTP-сервер в режим согласования TLS. Далее
клиент уже по протоколу TLS отправляет спецификацию в виде обычного текста, а именно версию протокола, которую он хочет
использовать, поддерживаемые методы шифрования, и т.д. В свою очередь сервер утверждает версию используемого протокола,
выбирает способ шифрования из предоставленного списка, прикрепляет свой сертификат и отправляет ответ клиенту. Версия
протокола и способ шифрования на данном моменте считаются утверждёнными, клиент проверяет присланный сертификат и
инициирует обмен ключами по Диффи-Хеллману. После этого сервер обрабатывает присланное клиентом сообщение, сверяет MAC,
и отправляет клиенту заключительное `Finished` сообщение в зашифрованном виде. Клиент же расшифровывает полученное
сообщение, сверяет MAC, и соединение считается установленным, после чего начинается обмен данными приложений.

## 7. Анализ Telnet и SSH трафика

### 7.1 SSH

Для подключения по SSH использовалась команда `ssh -T git@github.com`. При этом предварительно была сгенерирована пара
ключей, и публичный ключ был добавлен в GitHub. Передача данных осуществлялась по протоколу SSHv2, который передает
данные в зашифрованном виде.

![ssh-wireshark.png](images/task-5/ssh-wireshark.png)

Из отчета Wireshark видно, что сначала осуществляется конфигурация используемых для обмена данными ключей для шифровки,
а затем начинается сама зашифрованная передача данных.

![ssh-wireshark-example.png](images/task-5/ssh-wireshark-example.png)

Как видно в детальной информации о пакете с данными, прочитать сами данные Wireshark не смог.

### 7.2 Telnet

Подключение по Telnet производилось к маршрутизатору домашней сети при помощи программы PuTTY. IP-адрес: `192.168.1.36`;
порт: `23` (используется Telnet по умолчанию для установки соединения).

![telnet.png](images/task-5/telnet.png)

Подключившись к серверу, пройдя аутентификацию и выполнив пару команд, был полученный длинный отчет в Wireshark.

![telnet-wireshark.png](images/task-5/telnet-wireshark.png)

Как видно в детальном отчете, каждый пакет передается в открытом виде. Например, был найден пакет, передающий ответ на
запрос о текущей версии ОС.

## 8. Анализ TCP и UDP трафика

### 8.1 TCP

TCP (Transmission Control Protocol) – протокол транспортного уровня, реализующий надежную доставку потока данных путём
предварительного установления соединения. Имеет большую надёжность, реализуется за счёт квитирования, то есть при помощи
пакета-уведомление, который сигнализирует о том, что соответствующий пакет был получен.

Установка TCP соединения происходит в 3 этапа:

- Запрашивающая сторона (клиент) отправляет сегмент с флагом SYN, указывая номер порта сервера, к которому клиент хочет
  подсоединиться, и исходный номер последовательности клиента (предыдущий номер в буфере);
- Сервер отсылает флаг ACK с номером подтверждения принятого только что сегмента + 1 и флаг SYN также с номером очереди
  сегмента, только уже для этой стороны;
- В ответ на это клиент отправляет флаг ACK с номером принятого только что сегмента + 1.

При помощи команды `nslookup jetbrains.com` был получен IP-адрес для подключения по протоколу TCP:

![nslookup.png](images/task-5/nslookup.png)

Для установки TCP-соединения по IP-адресу `13.33.243.77` и порту `80` использовалась программ PuTTY.

Wireshark отследил следующие пакеты:

![tcp-wireshark.png](images/task-5/tcp-wireshark.png)

При подключении фигурирует 3 пакета:

- `SYN`
- `SYN`, `ACK`
- `ACK`

![tcp-connection-1.png](images/task-5/tcp-connection-1.png)

Первый пакет, который отправлен на IP-адрес `13.33.243.77`, содержит флаг `SYN`. Серверный порт – `80`, а клиентский –
`50901`, то есть непривилегированный номер порта, который выдаётся ОС. Номер последовательности и подтверждения равны 0.

![tcp-connection-2.png](images/task-5/tcp-connection-2.png)

Второй пакет, который является ответом сервера на первый, имеет флаги `SYN` и `ACK`. Номер последовательности на стороне
сервера равен 0, а номер подтверждения равен номеру последовательности клиента + 1, то есть единице.

![tcp-connection-3.png](images/task-5/tcp-connection-3.png)

Третий пакет, отправляемый клиентом, имеет флаг `ACK`. При этом номер последовательности на стороне клиента уже равен 1,
а номер подтверждения равен номеру последовательности сервера + 1, то есть единице.

После обмена этими тремя пакетами TCP-соединение считается установленным.

### 8.2 UDP

UDP в отличие от TCP это незащищенный протокол, предполагающий самостоятельное проектирование и реализацию механизмов
защиты от потери и переотправки пакетов. UDP не требует открывать соединение, и данные могут быть отправлены сразу же,
как только они подготовлены, что ускоряет процесс передачи данных. Таким образом, UDP лучше всего использовать в
клиент-серверных приложениях, которые работают с несколькими клиентами, отправляющими небольшие запросы/ответы и
получающими такие же короткие ответы от сервера.

Для генерации UDP трафика была использована команда `nslookup -type=A jetbrains.com`. Утилита `nslookup` обращается к
DNS-серверу, посылая при этом UDP-запросы:

![udp-nslookup-1.png](images/task-5/udp-nslookup-1.png)

Первый пакет с запросом `nslookup` типа A с IP-адреса `192.168.1.38` и порта `64787` был отправлен на DNS-серверу по
IP-адресу `8.8.8.8` на порт `53`.

![udp-nslookup-2.png](images/task-5/udp-nslookup-2.png)

В ответ был получен пакет с информацией о 4 IP-адресах, соответствующих домену `jetbrains.com`.

## 9. Выводы

В данной работе были изучены возможности программы Wireshark по анализу трафика сети. С помощью данной утилиты был
проанализированы пакеты нескольких протоколов, а также в некоторых случаях была рассмотрена их защищённость.

# 6. Nmap network scanning

## 1. Цель работы

Изучение возможностей утилиты Nmap.

## 2. Ход работы

## 3. Обычное использование Nmap

Для запуска Nmap в обычном режиме была использована команда `nmap github.com`:

![nmap.png](images/task-6/nmap.png)

С помощью DNS-сервера программа пытается определить соответствие имени сканируемому IP-адресу. Если операция прошла
успешно, то в самом начале Nmap указывает реальное имя компьютера. Как видно из рисунка, IP-адресу `140.82.121.3`
соответствует имя `github.com`. Далее Nmap отображает информацию о закрытых или заблокированных портах (Not shown 997
filtered ports), а затем выводит порты, имеющие другой статус, включая информацию о том, может ли он принимать различные
значения, которые будут свидетельствовать о предполагаемом сервисе, использующем этот порт и статусе порта, определенном
Nmap:

- open (открытый порт) — порт открыт, и служба принимает TCP или UDP-соединения по этому порту (данный порт наиболее
  уязвим для взлома);
- filtered — порт закрыт брандмауэром, иной блокирующей программой или службой (правила роутера, аппаратный брандмауэр и
  т.п.);
- closed — порт закрыт, так как нет службы или иной программы, прослушивающей этот порт на компьютере.

## 4. Сканирование на предмет наличия компьютера в сети

Самым простым является метод обнаружения работающих компьютеров с помощью режима ping. Для этого в командной строке
необходимо использовать флаг `-sP`.

![nmap-sp.png](images/task-6/nmap-sp.png)

Сетевой сканер Nmap послал ICMP эхо-запросы заданному IP-адресу, получил ответ, а значит, сканируемый хост работает,
что и отображается в качестве результата сканирования.

Однако большинство брандмауэров блокируют ICMP-запросы, поэтому, даже если хост активен, но он не принимает эхо-запросы,
Nmap сообщит, что компьютера в сети не существует.

## 5. Обнаружение с помощью SYN/ACK и UPD-пакетов

Если какой-либо сервис прослушивает порт, а Nmap пытается установить с ним соединение (отсылает пакет с флагом SYN),
в ответ сервис может послать пакет с флагами `SYN`/`ACK`, что подтвердит наличие хоста в сети. Но при отсутствии сервиса
по этому порту сервер посылает в ответ пакет с флагом RST, что также указывает на то, что по заданному IP-адресу хост
существует. Если в ответ на посланный пакет `SYN` от сервера ничего не пришло — это значит, что, либо хост активен, либо
трафик блокируется брандмауэром. Чтобы обойти блокировку брандмауэра, разработан еще один метод сканирования. Сканер
Nmap обычно посылает пакеты с флагами `SYN`/`ACK` и пакет UDP по стандартному порту `80`, который чаще всего
используется для web-трафика и поэтому очень редко блокируется брандмауэром. С помощью ключей `-PS`, `-PA` и `-PU` можно
задавать, какой пакет будет отправлен серверу и по какому порту.

![nmap-ps-pa-pu.png](images/task-6/nmap-ps-pa-pu.png)

## 6. Обнаружение компьютера посредством различных ICMP-пакетов

Сетевой сканер Nmap имеет еще одну возможность определения наличия компьютера в сети. Для того чтобы воспользоваться
этой функцией, необходимо указать дополнительные ключи:

- `-PE` – использует эхо-запросы

![nmap-pe.png](images/task-6/nmap-pe.png)

- `-PP` – использует запросы даты/времени

![nmap-pp.png](images/task-6/nmap-pp.png)

- `-PM` – использует адреса маски сети

![nmap-pm.png](images/task-6/nmap-pm.png)

С помощью этих методов тоже можно получить ответ от хоста, однако, как оказалось GitHub именно последние 2 способа
блокирует.

## 7. Методы сканирования портов удаленного компьютера

Сетевой сканер Nmap предполагает применение разнообразных методов сканирования и получения необходимой информации.
Однако очень многие методы задействуют различные манипуляции с флагами TCP-пакетов на низком уровне, а потому для работы
требуют полномочий суперпользователя в системе. Используемые методы могут функционировать только отдельно друг от друга,
лишь сканирование UDP-портов может осуществляться одновременно с другими методами сканирования. Сканирование портов
основывается на методе отправки пакетов с измененными флагами при инициации TCP- и UDP-соединений.

### 7.1 Сканирование методом SYN

Наиболее распространенный метод, который используется по умолчанию, – это сканирование `TCP SYN`. Для большинства
исследуемых компьютеров этого метода вполне достаточно, чтобы определить открытые порты. `TCP SYN` сканирование
наиболее быстрое по сравнению с другими методами. Оно позволяет сканировать сотни портов в секунду, сохраняя при
этом сканирующий хост скрытым для сети, поскольку никогда не завершает TCP-соединение (большинство утилит мониторинга
не регистрируют данные соединения). Для использования этого метода необходимы права суперпользователя. Сканер Nmap
отправляет исследуемому хосту пакет с флагом `SYN`, как будто он хочет открыть обычное TCP-соединение. Если ответ (пакет
с флагами `SYN/ACK`) от запрашиваемого хоста получен, порт будет обозначен как открытый, а при получении пакета с флагом
`RST` — как закрытый. В случае если сканируемый компьютер не ответил, предполагается, что этот порт фильтруется
брандмауэром. Чтобы использовать данный метод сканирования, необходимо запустить Nmap с ключом `-sS`:

![nmap-ss.png](images/task-6/nmap-ss.png)

### 7.2 Сканирование с использованием системной функции connect()

Бывают ситуации, когда полномочия суперпользователя отсутствуют, а просканировать удаленный компьютер необходимо. В этом
случае Nmap использует метод, основанный на установлении соединения с помощью системной функции `connect()`, которую
применяет большинство приложений — p2p-клиенты, браузеры и сетевые приложения. При этом Nmap посылает запрос самой
операционной системе, которая и устанавливает TCP-соединение. Если соединение установлено, то порт помечается как
открытый, а если нет — как закрытый. После определения статуса порта Nmap прерывает соединение, то есть с помощью
функции `connect()` посылается пакет с флагом `RST`. Однако такой метод имеет один недостаток: поскольку соединение
устанавливается полностью, оно остается в логах и журналах сканируемой системы, а потому системы по мониторингу
практически всегда определят, какой компьютер произвел сканирование. В связи с этим данный метод применяется редко.
Чтобы запустить вышеописанное сканирование, необходимо запустить Nmap с ключом `-sT`.

![nmap-st.png](images/task-6/nmap-st.png)

### 7.3 Сканирование портов UDP-протокола

Наиболее распространенные сервисы, использующие UDP-протокол, — это DNS, SNMP и DHCP. Поскольку сканирование протокола
UDP более сложное и медленное по сравнению с TCP-сканированием, многие защитные системы пренебрегают им и игнорируют
прослушивание (фильтрацию) этих портов. Но в таком случае сервисы, прослушивающие данные порты, тоже могут быть уязвимы
для взлома, так как Nmap позволяет определить, какие порты открыты и что за сервисы их прослушивают. Поскольку
UDP-протокол не похож на TCP, метод сканирования отличается от рассмотренных ранее. Nmap посылает UDP-пакет с пустым
заголовком по всем исследуемым портам и ждет ответа. Если в ответ он получает ICMP-пакет с ошибкой `unreachable error`,
порт считается закрытым. При получении пакетов с другими ошибками Nmap считает, что порт фильтруется брандмауэром.
Полученный ответный UDP-пакет свидетельствует о наличии сервиса, и порт обозначается открытым. Если ответ не получен
после нескольких попыток, Nmap помечает порт как `open|filtered`, поскольку не может точно установить — открыт ли порт
или брандмауэр блокирует трафик на этом порту. Кроме того, многие компьютеры могут посылать за секунду ограниченное
количество ICMP-сообщений с ошибками. Это сделано для защиты от перегрузки сети. Чтобы уточнить состояние порта, можно
использовать ключ `-sV` (в этом случае Nmap пытается определить запущенный по сканируемому порту сервис и его версию),
но тогда скорость сканирования снижается на порядок. UDP-сканирование может быть запущено одновременно с любыми из
методов TCP-сканирования, поскольку они применяют разные протоколы. Запуск UDP-сканирования происходит при указании
ключа `-sU`.

![nmap-su.png](images/task-6/nmap-su.png)

### 7.4 Сканирование с помощью методов FIN, Xmax и Null

Поскольку TCP-соединение базируется на трехходовом установлении связи, путем прерывания последовательности соединения
можно также получить информацию о закрытых и открытых портах исследуемого хоста. Существует метод `FIN` сканирования,
при котором удаленному хосту посылаются пакеты с флагом `FIN`, которые обычно применяются при закрытии соединения. В
этом случае закрытый порт хоста, в соответствии со спецификацией протокола TCP, должен послать ответный пакет с флагом
`RST`. Если же порт открыт или блокируется брандмауэром, ответа от него не будет. Как и в случае `SYN` сканирования,
соединение устанавливается не полностью, поэтому информации в системных логах исследуемого хоста может и не остаться, в
то же время большинство систем мониторинга могут зафиксировать этот тип сканирования. Данный метод является более
скрытным по сравнению с TCP connect-сканированием и позволяет определить, закрыт порт или открыт (блокируется), поэтому
существуют несколько модификаций этого метода. При использовании метода null-сканирования вместо пакета с `FIN` флагом
отсылается пакет с пустым заголовком (0 бит, все флаги отключены). Этот метод работает по вышеописанному принципу. Еще
один метод, имеющий схожий алгоритм работы, называется `Xmas` сканирование. В этом случае хосту отсылается пакет,
раскрашенный несколькими флагами (`FIN`, `PSH` и `URG`). Для каждого из рассмотренных методов существуют собственные
ключи: `-sN`, `-sF` и `-sX`.

![nmap-sn.png](images/task-6/nmap-sn.png)

![nmap-sf.png](images/task-6/nmap-sf.png)

![nmap-sx.png](images/task-6/nmap-sx.png)

Сравнивая результаты сканирования видно, что с их помощью все порты были определены как `open|filtred`.

### 7.5 Сканирование с помощью методов ACK и Window

Для определения, какие порты на компьютере находятся в статусе `filtered`, а какие в `unfiltered`, существует отдельно
вынесенный тип сканирования — `ACK`. Его также можно задействовать с помощью ключа `--scanflags ACK`. Поскольку многие
брандмауэры осуществляют просмотр лишь `SYN` пакетов на определенном порту, выполняя тем самым фильтрацию, с помощью
отсылки пакетов с флагом `ACK` с большой долей вероятности можно определить, существует ли на исследуемом компьютере
брандмауэр или нет. Пакет с флагом `ACK` в этом случае отсылается не как часть соединения, а отдельно. В случае если
принимающая сторона отсылает обратный пакет с флагом `RST` (соответственно порт не блокируется брандмауэром), порт
помечается как `unfiltered`, если же хост не отвечает на пакет, то на нем установлен брандмауэр и порт находится в
статусе filtered. Для активации этого метода необходимо запустить Nmap с ключом `-sA`.

![nmap-sa.png](images/task-6/nmap-sa.png)

У этого метода существует аналог, который работает по такому же принципу, но несколько иначе интерпретирует полученные
от хоста результаты. Сканирование методом TCP Window предполагает, что на некоторых хостах службы используют
положительное значение поля `window` в ответном пакете (не ноль). Поэтому с помощью данного метода Nmap анализирует
заголовки приходящих пакетов с флагом RST, и если приходящий пакет содержит положительное значение поля, то Nmap
помечает этот порт открытым. Получение пакета с нулевым значением поля означает, что порт закрыт. Чтобы активировать
этот метод сканирования, необходимо ввести ключ `-sW`.

![nmap-sw.png](images/task-6/nmap-sw.png)

### 7.6 Сканирование методом Maimon

Еще одним методом сканирования на основе трехходового соединения является метод, описанный специалистом по имени Uriel
Maimon. Его метод практически идентичен методам `FIN`, `Xmas` и `Null`, за исключением того, что посылаются пакеты с
флагами `FIN/ACK`. Здесь, если порт закрыт, хост должен отвечать пакетом `RST`. Чтобы активировать этот метод
сканирования, необходимо ввести ключ `-sM`.

![nmap-sm.png](images/task-6/nmap-sm.png)

### 7.7 Скрытое сканирование с использованием алгоритма idlescan

Ни один из рассмотренных методов не позволяет полностью скрыть IP-адрес сканирующего хоста. Поскольку подмена IP-адреса
исходящего пакета не так сложна, был найден метод сканирования, при котором исследуемый хост не может определить точного
IP-адреса хоста, с которого производится сканирование. Метод `idlescan` по своему алгоритму работы практически идентичен
`SYN` сканированию. Чтобы понять, каким образом при этом скрывается IP-адрес сканирующего компьютера, необходимо знать,
что каждый IP-пакет имеет свой номер (fragment identification number, IPID). Многие операционные системы увеличивают
этот номер для каждого следующего посланного пакета, поэтому можно легко определить, сколько пакетов послал хост. При
этом стоит учитывать, что если компьютер получил пакет с флагами `SYN/ACK` от адреса, у которого он соединения не
запрашивал, то в ответ он пошлет пакет с флагом `RST`. Этот метод предполагает использование еще одного хоста-зомби,
от имени которого будут идти пакеты к сканируемому компьютеру. Далее рассмотрим алгоритм работы `idlescan` метода.
Пусть сканирующий компьютер будет attacker, хост-зомби — zombie, а сканируемый компьютер — target.

Первый случай — исследуемый порт открыт:

- attacker посылает пакет с флагами `SYN/ACK` zombie, а в ответ zombie посылает пакет с флагом `RST`;
- attacker посылает пакет с флагом `SYN` по искомому порту от имени компьютера zombie;
- target посылает ответный запрос с флагами `SYN/ACK` компьютеру zombie. В ответ zombie посылает пакет с флагом `RST`
  хосту target, так как zombie не собирался устанавливать с ним соединение;
- attacker посылает пакет с флагом `SYN/ACK` компьютеру zombie, в ответ zombie посылает пакет с флагом `RST`.

Второй случай — порт закрыт:

- attacker посылает пакет с флагами `SYN/ACK` zombie, в ответ zombie посылает пакет с флагом `RST`;
- attacker посылает пакет с флагом `SYN` по искомому порту от лица компьютера zombie;
- target посылает пакет с флагом `RST` компьютеру zombie. В ответ zombie ничего не посылает;
- attacker посылает пакет с флагом `SYN/ACK` компьютеру zombie, в ответ zombie посылает пакет с флагом `RST`

Таким образом, путем простой арифметики можно вычислить, открыт или закрыт порт на исследуемом компьютере. Преимущество
данного способа заключается в том, что выявить IP-адрес сканирующего компьютера очень сложно, поскольку компьютер target
считает, что сканирование было произведено компьютером zombie, а запросы сканирующего компьютера остаются только в
журналах zombie. Чтобы активировать этот способ сканирования, необходимо ввести ключ `-sI <zombie-port>`, где zombie —
название или IP-адрес хоста, от лица которого будет производиться сканирование, а port — порт для связи сканирующего
хоста и zombie (по умолчанию 80-й, поскольку на большинстве компьютеров этот порт открыт для web-трафика).

![nmap-si-1.png](images/task-6/nmap-si-1.png)

![nmap-si-2.png](images/task-6/nmap-si-2.png)

### 7.8 Сканирование на наличие открытых протоколов

В некоторых случаях необходимо определить открытые протоколы на удаленном хосте. Поскольку каждому IP-протоколу
транспортного уровня присвоен собственный порядковый номер, а каждый IP-пакет имеет поле `protocol`, которое указывает
на тип заголовков пакетов и номер протокола, можно узнать, какие протоколы открыты на исследуемом хосте. Для определения
доступности протокола на хосте Nmap посылает несколько пакетов с пустыми заголовками, содержащими в поле `protocol`
только номер протокола. В случае, если протокол недоступен, компьютер вернет ICMP-сообщение "protocol unreachable".
Если в ответ хост не посылает пакетов — это может означать, что, либо протокол доступен, либо брандмауэр блокирует
ICMP-трафик. Такая ситуация очень схожа с UDP-сканированием, где также невозможно точно определить, открыт порт или
фильтруется брандмауэром. Чтобы активировать сканирование протоколов, необходимо задействовать ключ `-sO`.

![nmap-so.png](images/task-6/nmap-so.png)

## 8 Определение версий запущенных служб

Nmap может идентифицировать версии запущенных на удаленном ПК сервисов, при условии, что порты того или иного сервиса
открыты. Определение сервисов поможет получить более четкое представление, насколько уязвим исследуемый компьютер и
какие дыры в сервисах могут оставаться открытыми для взлома. Чтобы получить информацию о версии запущенного сервиса,
Nmap пользуется своей базой данных, которая включает специфические метки, свойственные именно этой версии программного
обеспечения. Сбор информации происходит после любого сканирования с любым методом анализа открытых портов. Определение
версий программ не всегда дает положительный результат, однако в большинстве случаев информация, полученная таким
способом, помогает составить представление об используемой системе на удаленном компьютере. В случае, если Nmap получает
информацию о хосте, но не может сопоставить ее с конкретным описанием в своей базе данных, программа выводит результат
на экран.

![nmap-version-all.png](images/task-6/nmap-version-all.png)

## 9. Определение версии ОС на удаленном компьютере

Одной из самых интересных опций является определение операционной системы удаленного компьютера. В этом случае
применяется модернизированный метод, предназначенный для определения версий запущенных служб. Nmap производит различные
тесты, посылая пакеты по разным протоколам с различными условиями на исследуемый компьютер. Сравнивая полученные
результаты с эталонными значениями, указанными в файле `Nmap-os-fingerprints`, программа выдает сводный результат по
компьютеру. В зависимости от количества и качества полученной информации, Nmap может определить производителя ОС, ее
примерную версию и тип оборудования, поскольку не всегда конечным результатом сканирования является компьютер — это
может быть также роутер, управляемый коммутатор и т.п. Для того чтобы активировать этот метод сканирования, необходимо
указать флаг `-O`, а также флаг `-A`, который активизирует определение версии операционной системы и версий запущенных
служб.

![nmap-ao-1.png](images/task-6/nmap-ao-1.png)

![nmap-ao-2.png](images/task-6/nmap-ao-2.png)

![nmap-ao-3.png](images/task-6/nmap-ao-3.png)

![nmap-ao-4.png](images/task-6/nmap-ao-4.png)

![nmap-ao-5.png](images/task-6/nmap-ao-5.png)

## 10. Настройки временных задержек

Высокая скорость работы определяется временными параметрами ответов и посылки пакетов. По умолчанию, чтобы получить
правдоподобные результаты сканирования, Nmap использует наиболее эффективные параметры времени. Однако специалистам
безопасности, которые пользуются этим сканером, для определенных методов сканирования могут понадобиться специальные
установки временных констант. В связи с этим разработчики Nmap предусмотрели установку некоторых констант вручную, а
также возможность задать «расписание» сканирования. Некоторые ключи используют установку времени, которое по умолчанию
вводится в миллисекундах, однако существует возможность записи времени в виде `s`, `m` и `h` — эти буквенные аргументы
добавляются в конец числового значения, значительно сокращая запись и упрощая ее. Например, `600000`, `600s`, `10m`
обозначают одно и то же время.

![performance-config.png](images/task-6/performance-config.png)

![scan-scheduling-config.png](images/task-6/scan-scheduling-config.png)

## 11. Сравнение Nmap с netcat

`netcat` — утилита Unix, позволяющая устанавливать соединения TCP и UDP, принимать оттуда данные и передавать их.
Несмотря на свою полезность и простоту, данная утилита не входит ни в какой стандарт (например, POSIX).

Формат утилиты: `nc host port`

Создает TCP-подключения с указанными реквизитами и замыканием стандартного ввода на сетевой вывод и наоборот,
стандартного вывода на сетевой ввод. При невозможности подключения программа выводит сообщение об ошибке на stderr.

Применение:

- Тестирование и ручная работа с сетевыми протоколами;
- Проверка доступности портов;
- Сканирование портов;
- Сетевой интерфейс для командного интерпретатора UNIX;
- Написание shell-сценариев эмулируюших HTTP запросы;
- Перенаправить или проксировать TCP/UDP/SCTP трафик на другие порты или хосты;
- Шифровать связь с помощью SSL и передавать её по IPv4 или IPv6;
- Выступать в качестве сетевого шлюза для выполнения системных команд с перенаправлением ввода/вывода в сеть;
- Выступать в качестве посредника соединений, позволяя двум (или даже более) клиентам подключаться друг к другу через
  третий (посреднический) сервер;
- (С флагом `-l`) создание простых серверов, обычно тестовых;
- (Совместно с `inetd`) перенаправление портов.

Эти возможности становятся ещё более мощными и универсальными в сочетании друг с другом.

Таким образом, можно сделать вывод, что netcat является более гибкой утилитой и предоставляет больше возможностей в
сравнении с Nmap, так как позволяет решать широкий спектр задач по тестированию безопасности и администрированию. Netcat
подходит для интерактивного использования или в качестве подключенного к сети бэкенда для других инструментов.

## 12. Выводы

В ходе данной работы были изучены возможности консольной утилиты Nmap для сканирования и анализа компьютерных сетей.
Данная утилита является очень гибкой и имеет множество возможных режимов работы, каждый из которых может быть полезен в
каком-то конкретном случае для получения более подробной информации о сегменте сети и о хостах.

# 7. Netcat and Cryptcat utilities

## 1. Цель работы

Исследование взаимодействия процессов на разных хостах с использованием утилит Netcat и её защищенного аналога Cryptcat.

## 2. Ход работы

Устройства, за которыми производилось исследование утилит, подключены с помощью Wi-Fi роутера к домашней сети. В таблице
ниже приведены некоторые параметры устройств в этой сети.

| Тип               | IP адрес       |
|-------------------|----------------|
| Хост с OC Linux   | 192.168.31.239 |
| Хост с ОС Windows | 192.168.31.26  |

## 3. Утилита Netcat

**Netcat** — это сетевой инструмент для чтения и записи данных через сетевые подключения с использованием TCP или UDP.

### 3.1. Netcat чат

Организуем простой чат с использованием утилиты Netcat. Для этого запустим на двух хостах два экземпляра Netcat, один из
которых будет находиться в состоянии слушателя, а второй инициировать подключение с первым. Подключение будет
производиться по порту `31337`.

**Флаги:**

- `-l` — прослушивать входящие соединения, а не инициировать подключение к удаленному хосту.
- `-p port` — устанаваливает порт прослушивания (в нашем случае `31337`).

![Chat listener](images/task-7/chat_listener.png)

![Chat connect](images/task-7/chat_connect.png)

В результате на хосте с ОС Windows был запущен слушатель, к которому в последствии подключился хост с ОС Linux. На
изображениях выше также продемонстрирован обмен сообщениями между двумя хостами.

### 3.2. Netcat передача файлов

Организуем передачу файлов с использованием утилиты Netcat. Попробуем передать текстовый файл с одного хоста на другой.
Содержимое файла представлено на рисунке ниже.

![Text file](images/task-7/text_file.png)

Для передачи файла запустим утилиту Netcat в режиме слушателя по порту 31337 на одном хосте и зададим передаваемый файл,
после чего инициируем соединение с другого хоста для получения передаваемого файла.

**Флаги:**

- `-v` — подробный режим отображения логов.
- `-l` — прослушивать входящие соединения, а не инициировать подключение к удаленному хосту.
- `-w timeout` — автоматически закрыть соединение, если соединение и stdin простаивают более *timeout* секунд.
- `-n` — не выполнять поиск имен через DNS

![File listener](images/task-7/file_listener.png)

![File connect](images/task-7/file_connect.png)

При попытке инициирования подключения у клиента появляется сообщение о том, что данный порт отрыты для этого ip адреса.
На стороне слушателя появилось сообщение о подключении клиента (по ip адресу видно, что подключился наш хост с ОС
Linux). Спустя 30 секунд бездействия произошло автоматическое закрытие соединения. В результате файл был успешно
передан.

## 4. Утилита Cryptcat

**Cryptcat** — это стандартный netcat, дополненный шифрованием twofish (симметричный алгоритм блочного шифрования с
размером блока 128 бит и длиной ключа до 256 бит).

Попробуем организовать чат с использованием утилиты cryptcat, а также проанализируем трафик с помощью сетевого снифера
Wireshark в случае защищенного и открытого соединений.

Принцип организации соединения остался таким же. Единственным отличием является наличие симметричного ключа.

**Флаги:**

- `-k keyword` — назначение симметричного ключа.

![Cryptcat listener](images/task-7/crypt_listener.png)

![Cryptcat connect](images/task-7/crypt_connection.png)

Воспользуемся сетевым снифером Wireshark и сравним трафик в случае защищенного/открытого соединения. В результате видим,
что пакеты переданные с помощью утилиты netcat в заголовке data содержат сообщения в открытом виде, что показано на
рисунке ниже.

![Netcat message](images/task-7/msg_uncrypt.png)

Cryptcat в свою очередь шифрует всю передаваемую информацию. На рисунке ниже показан пример зашифрованных данных в
заголовке data.

![Cryptcat message](images/task-7/msg_crypt.png)

## 5. Вывод

В данной работе мы познакомились с возможностями утилиты netcat и её безопасной версии cryptcat.

# 8. Firewalls, iptables rules

## 1. Цель работы

Исследование контроля и фильтрации проходящего сетевого трафика в соответствии с заданными правилами с использованием
утилиты `iptables`.

## 2. Ход работы

`iptables` — утилита командной строки, является стандартным интерфейсом управления работой межсетевого экрана
netfilter для ядер Linux. Iptables оперирует некими правилами (rules), на основании которых решается судьба пакета,
который поступил на интерфейс сетевого устройства.

### 2.1. Получение списка правил

Посмотреть текущие правила, установленные в `iptables`, можно при помощи команды: `sudo iptables -L`. Результат её
работы
представлен на рисунке ниже.

![iptables rules](images/task-8/rules_iptables.png)

### 2.2. Блокировка всего входящего трафика

Заблокируем весь входящий трафик. Для этого воспользуемся командой: `sudo iptables -A INPUT -j DROP`

**Флаги:**

- `-A chain rule-specificationУ `— добавить одно или несколько правил в конец выбранной цепочки.
- `-j target `— определить цель правила (что делать, если пакет соответствует правилу)

На рисунке ниже представлено состояние списка после добавления нового правила.

![Drop rule](images/task-8/rule_drop.png)

Вызова утилиты ping и использование браузера не дали результата. Число заблокированных пакетов можно увидеть на рисунке
ниже.

![Droped packages](images/task-8/drop_p.png)

### 2.3. Фильтрация входящего трафика

Попробуем отфильтровать весь трафик так, чтобы проходил только веб-трафик. Для этого:

1. Установим **DROP** в качестве политики по умолчанию

`sudo iptables -P INPUT DROP`

2. Разрешим трафик для loopback, чтобы внутренние сервисы нормально работали

`sudo iptables -A INPUT -i lo -j ACCEPT`

3. Теперь разрешим TCP и UDP соединения, которые сами создаем:

`sudo iptables -A INPUT -p tcp -m state --state ESTABLISHED,RELATED -j ACCEPT`

`sudo iptables -A INPUT -p udp -m state --state ESTABLISHED,RELATED -j ACCEPT`

4. Разрешим работу DNS-сервиса

`sudo iptables -A INPUT -p tcp --dport 53 -j ACCEPT`

`sudo iptables -A INPUT -p tcp --sport 53 -j ACCEPT`

`sudo iptables -A INPUT -p udp --dport 53 -j ACCEPT`

`sudo iptables -A INPUT -p udp --sport 53 -j ACCEPT`

5. Разрешим http и https

`sudo iptables -A INPUT -p tcp --dport 80 -j ACCEPT`

`sudo iptables -A INPUT -p tcp --dport 443 -j ACCEPT`

**Флаги:**

- `-A chain rule-specification` — добавить одно или несколько правил в конец выбранной цепочки.
- `-P chain target `— устанавливает политику для цепочки на заданную цель
- `-i name` — определяет имя интерфейса, через который был получен пакет
- `-j target` — определить цель правила (что делать, если пакет соответствует правилу)
- `-p protocol` — определяет протокол правила или пакета для проверки
- `--state state` — определяет состояния соединения, которым нужно соответствовать
    - **ESTABLISHED** — пакет связан с соединением, которое просматривало пакеты в обоих направлениях
    - **RELATED** — пакет запускает новое соединение, но связан с существующим соединением
- `--dport [ports]` — порт назначения является одним из заданных портов
- `--sport [ports]` — порт источника является одним из заданных портов

Итоговая таблица правил представлена на рисунке ниже

![Iptables final](images/task-8/final_rules.png)

Проверим работу нашего фильтра. Для эмуляции работы WEB-сервера используем Netcat.

![Netcat listener](images/task-8/nc_listener.png)

![Netcat client](images/task-8/nc_client.png)

В результате видим, что передача произошла без потерь.

## 3. Вывод

В ходе выполнения данной работы нами были изученные основные возможности управления цепочками правил при помощи утилиты
`iptables`.

По итогам работы нами был разработан сервер защищённый от внешних подключений.

# 9. Iptables implementation

## 1. Цель работы

Установка правил фильтрации исходящего трафика при помощи утилиты "iptables".

## 2. Ход работы

### 2.1.

Войдите в систему и определите IP-адрес вашего компьютера. Используйте утилиты ifconfig или ip. 
Результаты выполнения ваших команд и вводимых правил проверяйте и фиксируйте в отчете по лабораторной работе.

Воспользуемся утилитой ifconfig. Можно увидеть, что IP-адрес компьютера в сети - 192.168.80.129.

![ifconfig](images/task-9/ifconfig.png)

Просмотрим текущие правила, установленные в iptables: sudo iptables -L:

![iptables](images/task-9/iptables.png)

Утилита iptables является инструментом для управления настройками фаервола в Linux. Утилита iptables позволяет создавать правила фильтрации пакетов данных на основе различных критериев: IP-адрес, порт, протокол и т.д..

* Chain INPUT управляет входящим трафиком.
* Chain FORWARD управляет переадресуемым трафиком, т.е. в тех случаях, когда сервер выступает в роли маршрутизатора.
* Chain OUTPUT управляет исходящим трафиком.

### 2.2.

Для целей безопасности и сокрытия внутренней сетевой инфраструктуры ICMP запросы можно запретить командой:

```
sudo iptables -A INPUT -p icmp --icmp-type echo-request -j DROP
```

![dropped](images/task-9/dropped.png)

С помощью утилиты ping, использующей ICMP, проверим установленный запрет на ICMP:

![ping](images/task-9/ping.png)

Как и предполагалось, все пакеты были утеряны.

### 2.3.

Чтобы открыть хост для входящих ICMP запросов и исходящих ICMP ответов выполняются правила:

```
sudo iptables -I INPUT -i eth0 -p icmp --icmp-type 8 -s 0/0 -d $SERVER_IP -m state --state NEW,ESTABLISHED,RELATED -j ACCEPT
sudo iptables -I OUTPUT -i eth0 -p icmp --icmp-type 0 -s $SERVER_IP --d 0/0 -m state –state ESTABLISHED,RELATED -j ACCEPT
где: $SERVER_IP - IP-адрес хоста,
icmp-type 8 - эхо-запрос,
icmp-type 0 - эхо-ответ,
0/0 - любой адрес.
```

![opening](images/task-9/opening.png)

В результате получились следующие правила iptables:

![opened](images/task-9/opened.png)

Проверка доступности хоста представлена на картинке:

![ping1](images/task-9/ping1.png)

### 2.4.

Ограничение количества ping-запросов за единицу времени можно достичь с помощью команды:

```
sudo iptables -A INPUT -p icmp -m icmp --icmp-type 8 -m limit --limit 1/second --limit-burst 1 -j ACCEPT
```

Установка лимита и правила iptables представлены на картике ниже:

![antiddos](images/task-9/antiddos.png)

### 2.5.

Блокировать все входящие запросы с определенного адреса (например, 192.168.80.128) можно с помощью команды iptables:

```
sudo iptables -A INPUT -s 192.168.80.128 -j DROP
```

В результате таблица имеет следующий вид:

![userban](images/task-9/userban.png)

### 2.6.

Чтобы не пропускать все входящие запросы порта 80, надо выполнить:

```
sudo iptables -A INPUT -p tcp --dport 80 -j DROP
```

![no80s](images/task-9/no80s.png)

В таблице отдельно отмечено, что запрещён не только трафик по протоколу tcp, но и по протоколу http.

Аналогичной командой можно запретить все входящие запросы на порт 80 с определенного адреса (192.168.80.128):

```
sudo iptables -A INPUT -p tcp -s 192.168.80.128 --dport 80 -j DROP
```

![no80s1](images/task-9/no80s1.png)

### 2.7.

Сбросить трафик с определенного (00:0C:29:34:3E:47) MAC-адреса можно командой:

```
sudo iptables -A INPUT -m mac –mac-source 00:0C:29:34:3E:47 -j DROP
```

![mac](images/task-9/mac.png)

Компьютер с ОС Windows имеет указанный выше MAC-адрес, поэтому ping вновь не достигает цели:

![macping](images/task-9/macping.png)

### 2.8.

В правило выше можно внести исключение. Так, можно разрешить использование только протокола TCP. Это достигается с помощью команды:

```
sudo iptables -A INPUT -p tcp --destination-port 22 -m mac --mac-source 00:0C:29:34:3E:47 -j ACCEPT
```

![mac1](images/task-9/mac1.png)

## Вывод

В ходе данной лабораторной работы были изучены возможности по сетевому экранированию входящего трафика с помощью утилиты iptables. С её помощью можно задать ограничения для входящих, исходящих и пересылаемых сообщений. Также, был получен практический опыт по блокировке трафика.

# 10. Connections Limit

## 1. Цель работы

Исследовать средства ограничения количества соединений к серверу с клиентских компьютеров.

## 2. Ход работы

### 2.1.

Можно использовать, например, технологию iptables и модуль connlimit. Например, разрешение не более 3-х соединений по ssh на одного клиента реализуется правилом:

```
sudo iptables -A INPUT -p tcp --syn --dport 22 -m connlimit --connlimit-above 3 -j REJECT
```

Команда выполняется успешно:

![connlimit](images/task-10/connlimit.png)

### 2.2.

Продемонстрируйте возможность установления ограничения на количество одновременных соединений на примере ssh сервера.

В качестве ssh-сервера используется программа PuTTY. С её помощью происходит подключение к 22 порту localhost:

![puttySetup](images/task-10/puttySetup.png)

Можно видеть, что попытка создать более трёх подключений приводит к фатальной ошибке:

![putty](images/task-10/putty.png)

### 2.3.

Исследуйте и продемонстрируйте, по возможности, и другие технологии ограничения числа соединений с целью защиты от DDoS атак.

1. С помощью утилиты ifconfig для некоторого сетевого интерфейса wlp0s20f3 можно ограничить количество соединений:

```
sudo ifconfig wlp0s20f3 txqueuelen $value
```

Где "$value" - максимальное количество соединений; "txqueuelen" расшифровывается как "transmit queue length", длина очереди передачи данных.

2. Ограничить число соединений также можно на уровне системного файервола Linux с помощью команды "ufw limit": 

```
sudo ufw limit <service>
```

В данном случае, сервисом выступает ssh:

![ufw](images/task-10/ufw.png)

3. Один из вариантов ограничить число соединений, это иcпользовать функционал самого SSH-сервера. Например, в конфигурационном файле openssh сервера (/etc/ssh/sshd_config) можно задать параметр MaxSessions для ограничения максимального числа открытых сессий:

![sshConf](images/task-10/sshConf.png)

## Вывод

В ходе данной лабораторной работы были изучены различные средства по ограничению количества соединений к серверу с клиентских компьютеров.

# 11. L2, L3 Sockets sniffing

## 1. Цель работы

Исследование возможности RAW-сокетов предоставляющих доступ к полям заголовков сообщений протоколов уровней L2 и L3 модели OSI.

## 2. Ход работы

Работа выполнялась на Ubuntu 20.04.6, запущенной на виртуальной машине и имеющей IP 192.168.30.130.

## 3. Создание сниффера пакетов



Глобально логику работы сниффера можно поделить на несколько этапов:

- Поиск и выбор интерфейса для перехвата пакетов;
- Определение типа поступившего пакета;
- Вывод информации о пакете в лог-файл.

### 3.1. Поиск и выбор интерфейса для перехвата пакетов

Приведённый далее код позволяет пользователю получить список всех доступных интерфейсов, выбрать нужное и перехватывать все пакеты, которые поступают на данный интерфейс.

```cpp
        //First get the list of available devices
	printf("Finding available devices ... ");
	if( pcap_findalldevs( &alldevsp , errbuf) )
	{
		printf("Error finding devices : %s" , errbuf);
		exit(1);
	}
	printf("Done");
	
	//Print the available devices
	printf("\nAvailable Devices are :\n");
	for(device = alldevsp ; device != NULL ; device = device->next)
	{
		printf("%d. %s - %s\n" , count , device->name , device->description);
		if(device->name != NULL)
		{
			strcpy(devs[count] , device->name);
		}
		count++;
	}
	
	//Ask user which device to sniff
	printf("Enter the number of the device you want to sniff : ");
	scanf("%d" , &n);
	devname = devs[n];
	
	//Open the device for sniffing
	printf("Opening device %s for sniffing ... " , devname);
	handle = pcap_open_live(devname , 65536 , 1 , 0 , errbuf);
```

```cpp
	pcap_loop(handle , -1 , process_packet , NULL);
```

Стоит отметить, что получениче доступа ко всем интерфейсам - операция, требующая root-прав, и именно поэтому сам сниффер необходимо будет запускать с использованием sudo.

### 3.2 Определение типа поступившего пакета

Приведённый далее код использует данные из заголовков пакетов для определения типа пакета и вызова соответствующей функции. Большая их часть (ICMP, TCP, UDP) функционируют поверх IP, и для них информацию о типе пакета можно получить из IP-заголовка.

```cpp
 	//Get the IP Header part of this packet , excluding the ethernet header
	struct ethhdr *eth = (struct ethhdr *)buffer;
	struct arphdr *arp;
	arp = (struct arphdr *) (buffer + sizeof(struct ethhdr));
	print_arp_packet(arp);
	
	
	struct iphdr *iph = (struct iphdr*)(buffer + sizeof(struct ethhdr));
	++total;
	switch (iph->protocol) //Check the Protocol and do accordingly...
	{
		case 1:  //ICMP Protocol
			++icmp;
			print_icmp_packet( buffer , size);
			break;
		
		case 2:  //IGMP Protocol
			++igmp;
			break;
		
		case 6:  //TCP Protocol
			++tcp;
			print_tcp_packet(buffer , size);
			break;
		
		case 17: //UDP Protocol
			++udp;
			print_udp_packet(buffer , size);
			break;
```

### 3.3. Вывод информации из заголовка

При помощи структур (struct) можно достаточно легко и просто "форматировать" выделенный заголовку фрагент памяти. В качестве примера приведём обработку TCP-заголовка:

```cpp
void print_tcp_packet(const u_char * Buffer, int Size)
{
	unsigned short iphdrlen;
	
	struct iphdr *iph = (struct iphdr *)( Buffer  + sizeof(struct ethhdr) );
	iphdrlen = iph->ihl*4;
	
	struct tcphdr *tcph=(struct tcphdr*)(Buffer + iphdrlen + sizeof(struct ethhdr));
			
	int header_size =  sizeof(struct ethhdr) + iphdrlen + tcph->doff*4;
	
	fprintf(logfile , "\n\n***********************TCP Packet*************************\n");	
		
	print_ip_header(Buffer,Size);
		
	fprintf(logfile , "\n");
	fprintf(logfile , "TCP Header\n");
	fprintf(logfile , "   |-Source Port      : %u\n",ntohs(tcph->source));
	fprintf(logfile , "   |-Destination Port : %u\n",ntohs(tcph->dest));
	fprintf(logfile , "   |-Sequence Number    : %u\n",ntohl(tcph->seq));
	fprintf(logfile , "   |-Acknowledge Number : %u\n",ntohl(tcph->ack_seq));
	fprintf(logfile , "   |-Header Length      : %d DWORDS or %d BYTES\n" ,(unsigned int)tcph->doff,(unsigned int)tcph->doff*4);
	//fprintf(logfile , "   |-CWR Flag : %d\n",(unsigned int)tcph->cwr);
	//fprintf(logfile , "   |-ECN Flag : %d\n",(unsigned int)tcph->ece);
	fprintf(logfile , "   |-Urgent Flag          : %d\n",(unsigned int)tcph->urg);
	fprintf(logfile , "   |-Acknowledgement Flag : %d\n",(unsigned int)tcph->ack);
	fprintf(logfile , "   |-Push Flag            : %d\n",(unsigned int)tcph->psh);
	fprintf(logfile , "   |-Reset Flag           : %d\n",(unsigned int)tcph->rst);
	fprintf(logfile , "   |-Synchronise Flag     : %d\n",(unsigned int)tcph->syn);
	fprintf(logfile , "   |-Finish Flag          : %d\n",(unsigned int)tcph->fin);
	fprintf(logfile , "   |-Window         : %d\n",ntohs(tcph->window));
	fprintf(logfile , "   |-Checksum       : %d\n",ntohs(tcph->check));
	fprintf(logfile , "   |-Urgent Pointer : %d\n",tcph->urg_ptr);
	fprintf(logfile , "\n");
	fprintf(logfile , "                        DATA Dump                         ");
	fprintf(logfile , "\n");
		
	fprintf(logfile , "IP Header\n");
	PrintData(Buffer,iphdrlen);
		
	fprintf(logfile , "TCP Header\n");
	PrintData(Buffer+iphdrlen,tcph->doff*4);
		
	fprintf(logfile , "Data Payload\n");	
	PrintData(Buffer + header_size , Size - header_size );
						
	fprintf(logfile , "\n###########################################################");
}
```

Самое интересное в приведённом выше коде - это создание структуры с заданным начальным адресом (сдвиг относительно начала всего буфера на размеры Ethernet- и IP-заголовков) и последующие достаточно простые операции обращения к необходимым значениям, например, **ntohs(tcph->source)**.

## 4. Тестирование сниффера

Тестирование сниффера производилось в паре с Wireshark - популярным и стабильным сниффером трафика.

### 4.1. Протокол ICMP

Выполним команду **ping 8.8.8.8**, проверим, какую информацию получится получить из перехваченных ICMP-пакетов:

![icmp-wireshark](images/task-11/icmp-wireshark.png)

![icmp-sniffer](images/task-11/icmp-sniffer.png)

### 4.2. Протокол TCP

Выполним команду для сканирования TCP-портов **sudo nmap -PS 192.168.1.1 -p 80**, проверим информацию, полученную из перехваченных пакетов:

![tcp-wireshark](images/task-11/tcp-wireshark.png)

![tcp-sniffer](images/task-11/tcp-sniffer.png)

### 4.3. Протокол UDP

Аналогично предыдущему пункту, выполним команду для сканирования TCP-портов **sudo nmap -sU 192.168.1.1 -p 80**, проверим информацию, полученную из перехваченных пакетов:

![udp-wireshark](images/task-11/udp-wireshark.png)

![udp-sniffer](images/task-11/udp-sniffer.png)

### 4.4. Протокол ARP

sudo arping 192.168.1.1

Для получения информации из ARP-пакетов воспользуемся командой **arping 192.168.1.1**, сравним полученную из пакетов информацию:

![arp-wireshark](images/task-11/arp-wireshark.png)

![arp-sniffer](images/task-11/arp-sniffer.png)

### 4.5. Результаты тестирования

Стоит отметить, что по непонятной причине не получилось одновременно запустить и сниффер, и wireshark - первая запущенная программа получала доступ к интерфейсу, а вторая в это время ничего не могла сделать. Из-за подобного поведения пришлось проводить тестирование на одинаковых командах/запросах, но в различные промежутки времени, из-за этого в пакетах возможны, например, различия в TCP/UDP портах.

Полученная при помощи сниффера информация соответствует эталонной, полученной из Wireshark (за исключением вышеописанного нюанса), и не противоречит здравому смыслу. Стоит отметить, что в сравнении с созданным сниффером Wireshark является куда более продвинутым и удобным в использовании вследствие большого количества сил и времени, затраченного на его разработку.

## 5. Выводы

В рамках данной работы был написан сниффер пакетов для протоколов ICMP, TCP, UDP и ARP. Работа сниффера была протестирована, результаты соответствуют аналогичным в Wireshark, что говорит о корректности созданной нами программы.

# Приложение 1.

Полный код sniffer.c

```cpp
/*
	Packet sniffer using libpcap library
*/
#include<pcap.h>
#include<stdio.h>
#include<stdlib.h> // for exit()
#include<string.h> //for memset

#include<sys/socket.h>
#include<arpa/inet.h> // for inet_ntoa()
#include<net/ethernet.h>
#include<netinet/ip_icmp.h>	//Provides declarations for icmp header
#include<netinet/udp.h>	//Provides declarations for udp header
#include<netinet/tcp.h>	//Provides declarations for tcp header
#include<netinet/ip.h>	//Provides declarations for ip header


#define ETH_P_ARP 0x0806
#define ARP_REQUEST 1
#define ARP_REPLY 2

typedef struct arphdr {
	u_int16_t htype;
        u_int16_t ptype;
	u_char hlen;
	u_char plen;
        u_int16_t oper;
	u_char sha[6];
	u_char spa[4];
	u_char tha[6];
	u_char tpa[4];

}arphdr_t;

void process_packet(u_char *, const struct pcap_pkthdr *, const u_char *);
void process_ip_packet(const u_char * , int);
void print_ip_packet(const u_char * , int);
void print_tcp_packet(const u_char *  , int );
void print_udp_packet(const u_char * , int);
void print_icmp_packet(const u_char * , int );
void print_arp_packet(arphdr_t *arpheader);
void PrintData (const u_char * , int);

FILE *logfile;
struct sockaddr_in source,dest;
int tcp=0,udp=0,icmp=0,others=0,igmp=0,arp=0,total=0,i,j;	

int main()
{
	pcap_if_t *alldevsp , *device;
	pcap_t *handle; //Handle of the device that shall be sniffed

	char errbuf[100] , *devname , devs[100][100];
	int count = 1 , n;
	
	//First get the list of available devices
	printf("Finding available devices ... ");
	if( pcap_findalldevs( &alldevsp , errbuf) )
	{
		printf("Error finding devices : %s" , errbuf);
		exit(1);
	}
	printf("Done");
	
	//Print the available devices
	printf("\nAvailable Devices are :\n");
	for(device = alldevsp ; device != NULL ; device = device->next)
	{
		printf("%d. %s - %s\n" , count , device->name , device->description);
		if(device->name != NULL)
		{
			strcpy(devs[count] , device->name);
		}
		count++;
	}
	
	//Ask user which device to sniff
	printf("Enter the number of the device you want to sniff : ");
	scanf("%d" , &n);
	devname = devs[n];
	
	//Open the device for sniffing
	printf("Opening device %s for sniffing ... " , devname);
	handle = pcap_open_live(devname , 65536 , 1 , 0 , errbuf);
	
	if (handle == NULL) 
	{
		fprintf(stderr, "Couldn't open device %s : %s\n" , devname , errbuf);
		exit(1);
	}
	printf("Done\n");
	
	logfile=fopen("log.txt","w");
	if(logfile==NULL) 
	{
		printf("Unable to create file.");
	}
	
	//Put the device in sniff loop
	pcap_loop(handle , -1 , process_packet , NULL);
	
	return 0;	
}

void process_packet(u_char *args, const struct pcap_pkthdr *header, const u_char *buffer)
{
	int size = header->len;
	
	//Get the IP Header part of this packet , excluding the ethernet header
	struct ethhdr *eth = (struct ethhdr *)buffer;
	struct arphdr *arp;
	arp = (struct arphdr *) (buffer + sizeof(struct ethhdr));
	print_arp_packet(arp);
	
	
	struct iphdr *iph = (struct iphdr*)(buffer + sizeof(struct ethhdr));
	++total;
	switch (iph->protocol) //Check the Protocol and do accordingly...
	{
		case 1:  //ICMP Protocol
			++icmp;
			print_icmp_packet( buffer , size);
			break;
		
		case 2:  //IGMP Protocol
			++igmp;
			break;
		
		case 6:  //TCP Protocol
			++tcp;
			print_tcp_packet(buffer , size);
			break;
		
		case 17: //UDP Protocol
			++udp;
			print_udp_packet(buffer , size);
			break;
		
		
		default: //Some Other Protocol like ARP etc.
			++others;
			break;
	}
	printf("TCP : %d   UDP : %d   ICMP : %d   IGMP : %d   Others : %d   Total : %d\r", tcp , udp , icmp , igmp , others , total);
}

void print_ethernet_header(const u_char *Buffer, int Size)
{
	struct ethhdr *eth = (struct ethhdr *)Buffer;
	
	fprintf(logfile , "\n");
	fprintf(logfile , "Ethernet Header\n");
	fprintf(logfile , "   |-Destination Address : %.2X-%.2X-%.2X-%.2X-%.2X-%.2X \n", eth->h_dest[0] , eth->h_dest[1] , eth->h_dest[2] , eth->h_dest[3] , eth->h_dest[4] , eth->h_dest[5] );
	fprintf(logfile , "   |-Source Address      : %.2X-%.2X-%.2X-%.2X-%.2X-%.2X \n", eth->h_source[0] , eth->h_source[1] , eth->h_source[2] , eth->h_source[3] , eth->h_source[4] , eth->h_source[5] );
	fprintf(logfile , "   |-Protocol            : %u \n",(unsigned short)eth->h_proto);
}

void print_ip_header(const u_char * Buffer, int Size)
{
	print_ethernet_header(Buffer , Size);
  
	unsigned short iphdrlen;
		
	struct iphdr *iph = (struct iphdr *)(Buffer  + sizeof(struct ethhdr) );
	iphdrlen =iph->ihl*4;
	
	memset(&source, 0, sizeof(source));
	source.sin_addr.s_addr = iph->saddr;
	
	memset(&dest, 0, sizeof(dest));
	dest.sin_addr.s_addr = iph->daddr;
	
	fprintf(logfile , "\n");
	fprintf(logfile , "IP Header\n");
	fprintf(logfile , "   |-IP Version        : %d\n",(unsigned int)iph->version);
	fprintf(logfile , "   |-IP Header Length  : %d DWORDS or %d Bytes\n",(unsigned int)iph->ihl,((unsigned int)(iph->ihl))*4);
	fprintf(logfile , "   |-Type Of Service   : %d\n",(unsigned int)iph->tos);
	fprintf(logfile , "   |-IP Total Length   : %d  Bytes(Size of Packet)\n",ntohs(iph->tot_len));
	fprintf(logfile , "   |-Identification    : %d\n",ntohs(iph->id));
	//fprintf(logfile , "   |-Reserved ZERO Field   : %d\n",(unsigned int)iphdr->ip_reserved_zero);
	//fprintf(logfile , "   |-Dont Fragment Field   : %d\n",(unsigned int)iphdr->ip_dont_fragment);
	//fprintf(logfile , "   |-More Fragment Field   : %d\n",(unsigned int)iphdr->ip_more_fragment);
	fprintf(logfile , "   |-TTL      : %d\n",(unsigned int)iph->ttl);
	fprintf(logfile , "   |-Protocol : %d\n",(unsigned int)iph->protocol);
	fprintf(logfile , "   |-Checksum : %d\n",ntohs(iph->check));
	fprintf(logfile , "   |-Source IP        : %s\n" , inet_ntoa(source.sin_addr) );
	fprintf(logfile , "   |-Destination IP   : %s\n" , inet_ntoa(dest.sin_addr) );
}

void print_tcp_packet(const u_char * Buffer, int Size)
{
	unsigned short iphdrlen;
	
	struct iphdr *iph = (struct iphdr *)( Buffer  + sizeof(struct ethhdr) );
	iphdrlen = iph->ihl*4;
	
	struct tcphdr *tcph=(struct tcphdr*)(Buffer + iphdrlen + sizeof(struct ethhdr));
			
	int header_size =  sizeof(struct ethhdr) + iphdrlen + tcph->doff*4;
	
	fprintf(logfile , "\n\n***********************TCP Packet*************************\n");	
		
	print_ip_header(Buffer,Size);
		
	fprintf(logfile , "\n");
	fprintf(logfile , "TCP Header\n");
	fprintf(logfile , "   |-Source Port      : %u\n",ntohs(tcph->source));
	fprintf(logfile , "   |-Destination Port : %u\n",ntohs(tcph->dest));
	fprintf(logfile , "   |-Sequence Number    : %u\n",ntohl(tcph->seq));
	fprintf(logfile , "   |-Acknowledge Number : %u\n",ntohl(tcph->ack_seq));
	fprintf(logfile , "   |-Header Length      : %d DWORDS or %d BYTES\n" ,(unsigned int)tcph->doff,(unsigned int)tcph->doff*4);
	//fprintf(logfile , "   |-CWR Flag : %d\n",(unsigned int)tcph->cwr);
	//fprintf(logfile , "   |-ECN Flag : %d\n",(unsigned int)tcph->ece);
	fprintf(logfile , "   |-Urgent Flag          : %d\n",(unsigned int)tcph->urg);
	fprintf(logfile , "   |-Acknowledgement Flag : %d\n",(unsigned int)tcph->ack);
	fprintf(logfile , "   |-Push Flag            : %d\n",(unsigned int)tcph->psh);
	fprintf(logfile , "   |-Reset Flag           : %d\n",(unsigned int)tcph->rst);
	fprintf(logfile , "   |-Synchronise Flag     : %d\n",(unsigned int)tcph->syn);
	fprintf(logfile , "   |-Finish Flag          : %d\n",(unsigned int)tcph->fin);
	fprintf(logfile , "   |-Window         : %d\n",ntohs(tcph->window));
	fprintf(logfile , "   |-Checksum       : %d\n",ntohs(tcph->check));
	fprintf(logfile , "   |-Urgent Pointer : %d\n",tcph->urg_ptr);
	fprintf(logfile , "\n");
	fprintf(logfile , "                        DATA Dump                         ");
	fprintf(logfile , "\n");
		
	fprintf(logfile , "IP Header\n");
	PrintData(Buffer,iphdrlen);
		
	fprintf(logfile , "TCP Header\n");
	PrintData(Buffer+iphdrlen,tcph->doff*4);
		
	fprintf(logfile , "Data Payload\n");	
	PrintData(Buffer + header_size , Size - header_size );
						
	fprintf(logfile , "\n###########################################################");
}

void print_udp_packet(const u_char *Buffer , int Size)
{
	
	unsigned short iphdrlen;
	
	struct iphdr *iph = (struct iphdr *)(Buffer +  sizeof(struct ethhdr));
	iphdrlen = iph->ihl*4;
	
	struct udphdr *udph = (struct udphdr*)(Buffer + iphdrlen  + sizeof(struct ethhdr));
	
	int header_size =  sizeof(struct ethhdr) + iphdrlen + sizeof udph;
	
	fprintf(logfile , "\n\n***********************UDP Packet*************************\n");
	
	print_ip_header(Buffer,Size);			
	
	fprintf(logfile , "\nUDP Header\n");
	fprintf(logfile , "   |-Source Port      : %d\n" , ntohs(udph->source));
	fprintf(logfile , "   |-Destination Port : %d\n" , ntohs(udph->dest));
	fprintf(logfile , "   |-UDP Length       : %d\n" , ntohs(udph->len));
	fprintf(logfile , "   |-UDP Checksum     : %d\n" , ntohs(udph->check));
	
	fprintf(logfile , "\n");
	fprintf(logfile , "IP Header\n");
	PrintData(Buffer , iphdrlen);
		
	fprintf(logfile , "UDP Header\n");
	PrintData(Buffer+iphdrlen , sizeof udph);
		
	fprintf(logfile , "Data Payload\n");	
	
	//Move the pointer ahead and reduce the size of string
	PrintData(Buffer + header_size , Size - header_size);
	
	fprintf(logfile , "\n###########################################################");
}

void print_icmp_packet(const u_char * Buffer , int Size)
{
	unsigned short iphdrlen;
	
	struct iphdr *iph = (struct iphdr *)(Buffer  + sizeof(struct ethhdr));
	iphdrlen = iph->ihl * 4;
	
	struct icmphdr *icmph = (struct icmphdr *)(Buffer + iphdrlen  + sizeof(struct ethhdr));
	
	int header_size =  sizeof(struct ethhdr) + iphdrlen + sizeof icmph;
	
	fprintf(logfile , "\n\n***********************ICMP Packet*************************\n");	
	
	print_ip_header(Buffer , Size);
			
	fprintf(logfile , "\n");
		
	fprintf(logfile , "ICMP Header\n");
	fprintf(logfile , "   |-Type : %d",(unsigned int)(icmph->type));
			
	if((unsigned int)(icmph->type) == 11)
	{
		fprintf(logfile , "  (TTL Expired)\n");
	}
	else if((unsigned int)(icmph->type) == ICMP_ECHOREPLY)
	{
		fprintf(logfile , "  (ICMP Echo Reply)\n");
	}
	
	fprintf(logfile , "   |-Code : %d\n",(unsigned int)(icmph->code));
	fprintf(logfile , "   |-Checksum : %d\n",ntohs(icmph->checksum));
	//fprintf(logfile , "   |-ID       : %d\n",ntohs(icmph->id));
	//fprintf(logfile , "   |-Sequence : %d\n",ntohs(icmph->sequence));
	fprintf(logfile , "\n");

	fprintf(logfile , "IP Header\n");
	PrintData(Buffer,iphdrlen);
		
	fprintf(logfile , "UDP Header\n");
	PrintData(Buffer + iphdrlen , sizeof icmph);
		
	fprintf(logfile , "Data Payload\n");	
	
	//Move the pointer ahead and reduce the size of string
	PrintData(Buffer + header_size , (Size - header_size) );
	
	fprintf(logfile , "\n###########################################################");
}

void print_arp_packet (arphdr_t *arpheader) {
        
        
        printf("\n\n***********************ARP Packet*************************\n"); 
	printf("Hardware type: %s\n", (ntohs(arpheader->htype) == 1) ? "Ethernet" : "Unknown");
	printf("Protocol type: %s\n", (ntohs(arpheader->ptype) == 0x0800) ? "IPv4" : "Unknown");
	printf("Operation type: %s\n", (ntohs(arpheader->oper) == ARP_REQUEST) ? "ARP Request" : "ARP Reply");
	printf("\nSender MAC: ");
	for (i=0;i<6;i++){
		printf("%02X:", arpheader->sha[i]);
	}
        printf("\nSender IP: ");
        for (i=0;i<4;i++){
                printf("%d.", arpheader->spa[i]);
        }
        printf("\nTarget MAC: ");
        for (i=0;i<6;i++){
                printf("%02X:", arpheader->tha[i]);
        }
        printf("\nTarget IP: ");
        for (i=0;i<4;i++){
                printf("%d.", arpheader->tpa[i]);
        }
        printf("\n###########################################################");
 

}

void PrintData (const u_char * data , int Size)
{
	int i , j;
	for(i=0 ; i < Size ; i++)
	{
		if( i!=0 && i%16==0)   //if one line of hex printing is complete...
		{
			fprintf(logfile , "         ");
			for(j=i-16 ; j<i ; j++)
			{
				if(data[j]>=32 && data[j]<=128)
					fprintf(logfile , "%c",(unsigned char)data[j]); //if its a number or alphabet
				
				else fprintf(logfile , "."); //otherwise print a dot
			}
			fprintf(logfile , "\n");
		} 
		
		if(i%16==0) fprintf(logfile , "   ");
			fprintf(logfile , " %02X",(unsigned int)data[i]);
				
		if( i==Size-1)  //print the last spaces
		{
			for(j=0;j<15-i%16;j++) 
			{
			  fprintf(logfile , "   "); //extra spaces
			}
			
			fprintf(logfile , "         ");
			
			for(j=i-i%16 ; j<=i ; j++)
			{
				if(data[j]>=32 && data[j]<=128) 
				{
				  fprintf(logfile , "%c",(unsigned char)data[j]);
				}
				else 
				{
				  fprintf(logfile , ".");
				}
			}
			
			fprintf(logfile ,  "\n" );
		}
	}
}

```
